#include <stdint.h>
#include <string.h>
#include <stdio.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#include "resample.h"

void *memmem(const void *h0, size_t k, const void *n0, size_t l);

typedef struct {
#ifdef _WIN64
	uint8_t ResampleOut[128];
	uint8_t Resize[64];
#else
	uint8_t ResampleOut[32];
	uint8_t Resize[32];
#endif
} pattern_t;


class Hook {
public:
	Hook() : m_textVA(NULL), m_addr(NULL) {}
	Hook(LPVOID textVA, DWORD textSize) : m_textVA(textVA), m_textSize(textSize), m_addr(NULL) {}

	bool hook(void *addr, void *target) {
		if (m_textVA == NULL || m_addr != NULL) {
			return false;
		}
		if (!setProtection()) {
			return false;
		}
		m_addr = (uint8_t *)addr;
		memcpy(m_orig, m_addr, m_bytes);
		#ifdef _WIN64
			memcpy(m_addr, "\x48\xb8", 2);  // movabs rax
			*(uint64_t *)(m_addr+2) = (uint64_t)target;
			memcpy(m_addr+10, "\xff\xe0\x90", 3);  // jmp rax; nop
		#else
			*(m_addr) = 0xe9;  // jmp
			*(uint32_t *)(m_addr+1) = (uint32_t)target - (uint32_t)(m_addr+5);  // relative displacement
			*(m_addr+5) = 0x90;  // nop
		#endif
		restoreProtection();
		return true;
	}

	void restore() {
		if (m_addr == NULL) {
			return;
		}
		if (!setProtection()) {
			return;
		}
		memcpy(m_addr, m_orig, m_bytes);
		m_addr = NULL;
		restoreProtection();
	}

private:
	bool setProtection() {
		if (m_textVA == NULL) {
			return false;
		}
		if (!VirtualProtect(m_textVA, m_textSize, PAGE_EXECUTE_READWRITE, &m_prot)) {
			return false;
		}
		return true;
	}
	void restoreProtection() {
		if (m_textVA != NULL) {
			DWORD t;
			VirtualProtect(m_textVA, m_textSize, m_prot, &t);
		}
	}
	
	#ifdef _WIN64
		static constexpr int m_bytes = 13;
		uint8_t m_orig[m_bytes];
	#else
		static constexpr int m_bytes = 6;
		uint8_t m_orig[m_bytes];
	#endif
	LPVOID m_textVA;
	DWORD m_textSize;
	uint8_t *m_addr;
	DWORD m_prot;
};


static bool getTextVAAndSize(LPVOID *textVA, DWORD *textSize) {
	const uint8_t *imageBase = (uint8_t *)GetModuleHandle(NULL);
	const PIMAGE_DOS_HEADER imageDosHeader = (PIMAGE_DOS_HEADER)imageBase;
	if (imageDosHeader->e_magic != 0x5a4d) {
		return false;
	}
	const PIMAGE_NT_HEADERS imageNTHeader = (PIMAGE_NT_HEADERS)(imageBase + imageDosHeader->e_lfanew);
	if (imageNTHeader->Signature != 0x4550) {
		return false;
	}
	const PIMAGE_FILE_HEADER imageFileHeader = &imageNTHeader->FileHeader;
	PIMAGE_SECTION_HEADER imageSectionHeader = (PIMAGE_SECTION_HEADER)
		((uint8_t *)imageFileHeader + sizeof(IMAGE_FILE_HEADER) + imageFileHeader->SizeOfOptionalHeader);
	for (int i = 0; i < imageFileHeader->NumberOfSections; i++, imageSectionHeader++) {
		if (strcmp((char *)imageSectionHeader->Name, ".text") == 0) {
			*textVA = (LPVOID)(imageBase + imageSectionHeader->VirtualAddress);
			*textSize = imageSectionHeader->Misc.VirtualSize;
			return true;
		}
	}
	return false;
}


static DWORD WINAPI MessageBoxThread(LPVOID lpParam) {
	MessageBox(NULL, "Resampler loaded", "", 0);
	return 0;
}

static Hook ResampleOutHook;

extern "C" {
__declspec(dllexport)
int ReaperPluginEntry(HINSTANCE hInstance, void *rec) {
	if (rec == NULL) {
		ResampleOutHook.restore();
		return 0;
	}
	
	constexpr int patterns = 2;
	pattern_t pattern[patterns];
	#ifdef _WIN64
		// v4
		pattern[0] = {
			{0x55, 0x48, 0x81, 0xEC, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8D, 
			0x6C, 0x24, 0x20, 0x48, 0xC7, 0x45, 0x00, 0xFE, 0xFF, 0xFF, 
			0xFF, 0x44, 0x0F, 0x29, 0x7D, 0x60, 0x44, 0x0F, 0x29, 0x55, 
			0x70, 0x44, 0x0F, 0x29, 0x4D, 0x40, 0x0F, 0x29, 0x7D, 0x30, 
			0x0F, 0x29, 0x75, 0x50, 0x4C, 0x89, 0xBD, 0xD0, 0x00, 0x00, 
			0x00, 0x4C, 0x89, 0xB5, 0xB0, 0x00, 0x00, 0x00, 0x4C, 0x89, 
			0xAD, 0xC0, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xA5, 0xA0, 0x00, 
			0x00, 0x00, 0x48, 0x89, 0xBD, 0xC8, 0x00, 0x00, 0x00, 0x48, 
			0x89, 0xB5, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x9D, 0xB8, 
			0x00, 0x00, 0x00, 0x48, 0x63, 0xBD, 0x40, 0x01, 0x00, 0x00, 
			0x44, 0x89, 0x8D, 0x94, 0x00, 0x00, 0x00, 0x44, 0x89, 0xC3, 
			0x48, 0x89, 0x95, 0xE8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xCC, 
			0x48, 0x83, 0xFF, 0x40, 0x0F, 0x8F, 0x35, 0x02},
			{0x41, 0x57, 0x57, 0x56, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x20, 
			0x89, 0xD7, 0x48, 0x89, 0xCE, 0x33, 0xC0, 0x83, 0xFF, 0x00, 
			0x0F, 0x4E, 0xF8, 0x8B, 0x46, 0x0C, 0x3B, 0xF8, 0x0F, 0x84, 
			0xC2, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x45, 0x0F, 0xB6, 0xC0, 
			0x45, 0x85, 0xC0, 0x74, 0x2D, 0x8B, 0x5E, 0x08, 0x3B, 0xF8, 
			0x7D, 0x29, 0x8B, 0x46, 0x10, 0xC1, 0xE0, 0x02, 0xF7, 0xD8, 
			0x03, 0xC3, 0xBA, 0x01}
		};
		// v5
		pattern[1] = {
			{0x55, 0x48, 0x81, 0xEC, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8D, 
			0x6C, 0x24, 0x20, 0x48, 0xC7, 0x45, 0x00, 0xFE, 0xFF, 0xFF, 
			0xFF, 0x44, 0x0F, 0x29, 0x7D, 0x40, 0x44, 0x0F, 0x29, 0x75, 
			0x30, 0x44, 0x0F, 0x29, 0x5D, 0x70, 0x44, 0x0F, 0x29, 0x45, 
			0x50, 0x0F, 0x29, 0x7D, 0x60, 0x4C, 0x89, 0xBD, 0xD0, 0x00, 
			0x00, 0x00, 0x4C, 0x89, 0xB5, 0xC0, 0x00, 0x00, 0x00, 0x4C, 
			0x89, 0xAD, 0xC8, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xA5, 0xB8, 
			0x00, 0x00, 0x00, 0x48, 0x89, 0xBD, 0xA8, 0x00, 0x00, 0x00, 
			0x48, 0x89, 0xB5, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x9D, 
			0xA0, 0x00, 0x00, 0x00, 0x48, 0x63, 0xBD, 0x40, 0x01, 0x00, 
			0x00, 0x44, 0x89, 0x8D, 0x94, 0x00, 0x00, 0x00, 0x44, 0x89, 
			0xC3, 0x48, 0x89, 0x95, 0xE8, 0x00, 0x00, 0x00, 0x49, 0x89, 
			0xCC, 0x48, 0x83, 0xFF, 0x40, 0x0F, 0x8F, 0x40},
			{0x41, 0x57, 0x57, 0x56, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x20, 
			0x89, 0xD7, 0x48, 0x89, 0xCE, 0x8B, 0x56, 0x0C, 0x33, 0xC0, 
			0x83, 0xFF, 0x00, 0x0F, 0x4E, 0xF8, 0x3B, 0xFA, 0x74, 0x09, 
			0x8B, 0x5E, 0x08, 0x45, 0x0F, 0xB6, 0xC0, 0xEB, 0x21, 0x45, 
			0x0F, 0xB6, 0xC0, 0x45, 0x85, 0xC0, 0x0F, 0x84, 0xCA, 0x00, 
			0x00, 0x00, 0x8B, 0x5E, 0x08, 0x89, 0xD8, 0xC1, 0xE8, 0x1F, 
			0x03, 0xC3, 0xD1, 0xF8}
		};
	#else  // x86
		// v4
		pattern[0] = {
			{0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xC0, 0x57, 0x56, 0x53, 0x81, 
			0xEC, 0xB4, 0x00, 0x00, 0x00, 0x8B, 0xF1, 0x8B, 0x5D, 0x10, 
			0x8B, 0x45, 0x14, 0x83, 0xF8, 0x40, 0x7F, 0x07, 0x8B, 0x45, 
			0x14, 0x85},
			{0x57, 0x56, 0x55, 0x53, 0x8B, 0xE9, 0x8B, 0x55, 0x08, 0x8B, 
			0x5C, 0x24, 0x14, 0x0F, 0xB6, 0x44, 0x24, 0x18, 0x85, 0xDB, 
			0x7F, 0x05, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xDA, 0x0F, 
			0x84, 0xBD}
		};
		// v5
		pattern[1]= {
			{0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xC0, 0x57, 0x56, 0x53, 0x83, 
			0xEC, 0x74, 0x8B, 0xF9, 0x8B, 0x5D, 0x10, 0x8B, 0x45, 0x14, 
			0x83, 0xF8, 0x40, 0x7F, 0x07, 0x8B, 0x45, 0x14, 0x85, 0xC0, 
			0x7F, 0x0E},
			{0x57, 0x56, 0x55, 0x53, 0x8B, 0xE9, 0x8B, 0x4D, 0x08, 0x8B, 
			0x5C, 0x24, 0x14, 0x0F, 0xB6, 0x54, 0x24, 0x18, 0x85, 0xDB, 
			0x7F, 0x05, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xD9, 0x74, 
			0x0B, 0x8B}
		};
	#endif
	
	LPVOID textVA = NULL;
	DWORD textSize = 0;
	void *pResampleOut = NULL, *pResize = NULL;
	if (!getTextVAAndSize(&textVA, &textSize)) {
		goto error;
	}
	for (int i = 0; i < patterns; i++) {
		pResampleOut = memmem(textVA, textSize, pattern[i].ResampleOut, sizeof(pattern[i].ResampleOut));
		if (pResampleOut == NULL) {
			continue;
		}
		pResize = memmem(textVA, textSize, pattern[i].Resize, sizeof(pattern[i].Resize));
		break;
	}
	if (pResampleOut == NULL || pResize == NULL) {
		MessageBox(NULL, "Reaper version not supported", "", 0);
		return 0;
	}
	char msg[64];
	#ifdef _WIN64
		sprintf(msg, "ResampleOut %llx Resize %llx", pResampleOut, pResize);
	#else
		sprintf(msg, "ResampleOut %lx Resize %lx", pResampleOut, pResize);
	#endif
	OutputDebugString(msg);
	
	WDL_HeapBuf::pResize = decltype(WDL_HeapBuf::pResize)(pResize);
	ResampleOutHook = Hook(textVA, textSize);
	if (!ResampleOutHook.hook(pResampleOut, WDL_Resampler::pResampleOut.getAddr())) {
		goto error;
	}
	
	CreateThread(NULL, 0, MessageBoxThread, NULL, 0, 0);
	return 1;

error:
	MessageBox(NULL, "Error loading resampler", "", 0);
	return 0;
}
}