#include <stdint.h>
#include <string.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#include "resample.h"

void *memmem(const void *h0, size_t k, const void *n0, size_t l);

typedef struct {
#ifdef _WIN64
	uint8_t ResampleOut[128];
	uint8_t Resize[64];
#else
	uint8_t ResampleOut[32];
	uint8_t Resize[32];
#endif
} pattern_t;

typedef struct {
	uint8_t *ResampleOut;
	uint8_t *orig;
	int origSize;
} patchinfo_t;
static patchinfo_t p;


static LPVOID textVA = NULL;
static DWORD textSize = 0;

static bool getTextVAAndSize() {
	const uint8_t *imageBase = (uint8_t *)GetModuleHandle(NULL);
	const PIMAGE_DOS_HEADER imageDosHeader = (PIMAGE_DOS_HEADER)imageBase;
	if (imageDosHeader->e_magic != 0x5a4d) {
		return false;
	}
	const PIMAGE_NT_HEADERS imageNTHeader = (PIMAGE_NT_HEADERS)(imageBase + imageDosHeader->e_lfanew);
	if (imageNTHeader->Signature != 0x4550) {
		return false;
	}
	const PIMAGE_FILE_HEADER imageFileHeader = &imageNTHeader->FileHeader;
	PIMAGE_SECTION_HEADER imageSectionHeader = (PIMAGE_SECTION_HEADER)
		((uint8_t *)imageFileHeader + sizeof(IMAGE_FILE_HEADER) + imageFileHeader->SizeOfOptionalHeader);
	for (int i = 0; i < imageFileHeader->NumberOfSections; i++, imageSectionHeader++) {
		if (strcmp((char *)imageSectionHeader->Name, ".text") == 0) {
			textVA = (LPVOID)(imageBase + imageSectionHeader->VirtualAddress);
			textSize = imageSectionHeader->Misc.VirtualSize;
			return true;
		}
	}
	return false;
}

static bool patch() {
	DWORD prot;
	if (!VirtualProtect(textVA, textSize, PAGE_EXECUTE_READWRITE, &prot)) {
		return false;
	}
	#ifdef _WIN64
		memcpy(p.ResampleOut, "\x48\xb8", 2);  // movabs rax
		*(uint64_t *)(p.ResampleOut+2) = (uint64_t)WDL_Resampler::pResampleOut.getAddr();
		memcpy(p.ResampleOut+10, "\xff\xe0\x90", 3);  // jmp rax; nop
	#else
		*(p.ResampleOut) = 0xe9;  // jmp
		*(uint32_t *)(p.ResampleOut+1) = (uint32_t)WDL_Resampler::pResampleOut.getAddr() - (uint32_t)(p.ResampleOut+5);  // relative displacement
		*(p.ResampleOut+5) = 0x90;  // nop
	#endif
	DWORD t;
	VirtualProtect(textVA, textSize, prot, &t);
	return true;
}

static void restore() {
	DWORD prot;
	if (!VirtualProtect(textVA, textSize, PAGE_EXECUTE_READWRITE, &prot)) {
		return;
	}
	memcpy(p.ResampleOut, p.orig, p.origSize);
	DWORD t;
	VirtualProtect(textVA, textSize, prot, &t);
}


static DWORD WINAPI MessageBoxThread(LPVOID lpParam) {
	MessageBox(NULL, "Resampler loaded", "", 0);
	return 0;
}

static bool loaded = false;
extern "C" {
__declspec(dllexport)
int ReaperPluginEntry(HINSTANCE hInstance, void *rec) {
	if (rec == NULL && loaded) {
		restore();
		return 0;
	}
	
	constexpr int patterns = 2;
	pattern_t pattern[patterns];
	#ifdef _WIN64
		// v4
		pattern[0] = {
			{0x55, 0x48, 0x81, 0xEC, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8D, 
			0x6C, 0x24, 0x20, 0x48, 0xC7, 0x45, 0x00, 0xFE, 0xFF, 0xFF, 
			0xFF, 0x44, 0x0F, 0x29, 0x7D, 0x60, 0x44, 0x0F, 0x29, 0x55, 
			0x70, 0x44, 0x0F, 0x29, 0x4D, 0x40, 0x0F, 0x29, 0x7D, 0x30, 
			0x0F, 0x29, 0x75, 0x50, 0x4C, 0x89, 0xBD, 0xD0, 0x00, 0x00, 
			0x00, 0x4C, 0x89, 0xB5, 0xB0, 0x00, 0x00, 0x00, 0x4C, 0x89, 
			0xAD, 0xC0, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xA5, 0xA0, 0x00, 
			0x00, 0x00, 0x48, 0x89, 0xBD, 0xC8, 0x00, 0x00, 0x00, 0x48, 
			0x89, 0xB5, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x9D, 0xB8, 
			0x00, 0x00, 0x00, 0x48, 0x63, 0xBD, 0x40, 0x01, 0x00, 0x00, 
			0x44, 0x89, 0x8D, 0x94, 0x00, 0x00, 0x00, 0x44, 0x89, 0xC3, 
			0x48, 0x89, 0x95, 0xE8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xCC, 
			0x48, 0x83, 0xFF, 0x40, 0x0F, 0x8F, 0x35, 0x02},
			{0x41, 0x57, 0x57, 0x56, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x20, 
			0x89, 0xD7, 0x48, 0x89, 0xCE, 0x33, 0xC0, 0x83, 0xFF, 0x00, 
			0x0F, 0x4E, 0xF8, 0x8B, 0x46, 0x0C, 0x3B, 0xF8, 0x0F, 0x84, 
			0xC2, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x45, 0x0F, 0xB6, 0xC0, 
			0x45, 0x85, 0xC0, 0x74, 0x2D, 0x8B, 0x5E, 0x08, 0x3B, 0xF8, 
			0x7D, 0x29, 0x8B, 0x46, 0x10, 0xC1, 0xE0, 0x02, 0xF7, 0xD8, 
			0x03, 0xC3, 0xBA, 0x01}
		};
		// v5
		pattern[1] = {
			{0x55, 0x48, 0x81, 0xEC, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8D, 
			0x6C, 0x24, 0x20, 0x48, 0xC7, 0x45, 0x00, 0xFE, 0xFF, 0xFF, 
			0xFF, 0x44, 0x0F, 0x29, 0x7D, 0x40, 0x44, 0x0F, 0x29, 0x75, 
			0x30, 0x44, 0x0F, 0x29, 0x5D, 0x70, 0x44, 0x0F, 0x29, 0x45, 
			0x50, 0x0F, 0x29, 0x7D, 0x60, 0x4C, 0x89, 0xBD, 0xD0, 0x00, 
			0x00, 0x00, 0x4C, 0x89, 0xB5, 0xC0, 0x00, 0x00, 0x00, 0x4C, 
			0x89, 0xAD, 0xC8, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xA5, 0xB8, 
			0x00, 0x00, 0x00, 0x48, 0x89, 0xBD, 0xA8, 0x00, 0x00, 0x00, 
			0x48, 0x89, 0xB5, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x9D, 
			0xA0, 0x00, 0x00, 0x00, 0x48, 0x63, 0xBD, 0x40, 0x01, 0x00, 
			0x00, 0x44, 0x89, 0x8D, 0x94, 0x00, 0x00, 0x00, 0x44, 0x89, 
			0xC3, 0x48, 0x89, 0x95, 0xE8, 0x00, 0x00, 0x00, 0x49, 0x89, 
			0xCC, 0x48, 0x83, 0xFF, 0x40, 0x0F, 0x8F, 0x40},
			{0x41, 0x57, 0x57, 0x56, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x20, 
			0x89, 0xD7, 0x48, 0x89, 0xCE, 0x8B, 0x56, 0x0C, 0x33, 0xC0, 
			0x83, 0xFF, 0x00, 0x0F, 0x4E, 0xF8, 0x3B, 0xFA, 0x74, 0x09, 
			0x8B, 0x5E, 0x08, 0x45, 0x0F, 0xB6, 0xC0, 0xEB, 0x21, 0x45, 
			0x0F, 0xB6, 0xC0, 0x45, 0x85, 0xC0, 0x0F, 0x84, 0xCA, 0x00, 
			0x00, 0x00, 0x8B, 0x5E, 0x08, 0x89, 0xD8, 0xC1, 0xE8, 0x1F, 
			0x03, 0xC3, 0xD1, 0xF8}
		};
	#else  // x86
		// v4
		pattern[0] = {
			{0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xC0, 0x57, 0x56, 0x53, 0x81, 
			0xEC, 0xB4, 0x00, 0x00, 0x00, 0x8B, 0xF1, 0x8B, 0x5D, 0x10, 
			0x8B, 0x45, 0x14, 0x83, 0xF8, 0x40, 0x7F, 0x07, 0x8B, 0x45, 
			0x14, 0x85},
			{0x57, 0x56, 0x55, 0x53, 0x8B, 0xE9, 0x8B, 0x55, 0x08, 0x8B, 
			0x5C, 0x24, 0x14, 0x0F, 0xB6, 0x44, 0x24, 0x18, 0x85, 0xDB, 
			0x7F, 0x05, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xDA, 0x0F, 
			0x84, 0xBD}
		};
		// v5
		pattern[1]= {
			{0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xC0, 0x57, 0x56, 0x53, 0x83, 
			0xEC, 0x74, 0x8B, 0xF9, 0x8B, 0x5D, 0x10, 0x8B, 0x45, 0x14, 
			0x83, 0xF8, 0x40, 0x7F, 0x07, 0x8B, 0x45, 0x14, 0x85, 0xC0, 
			0x7F, 0x0E},
			{0x57, 0x56, 0x55, 0x53, 0x8B, 0xE9, 0x8B, 0x4D, 0x08, 0x8B, 
			0x5C, 0x24, 0x14, 0x0F, 0xB6, 0x54, 0x24, 0x18, 0x85, 0xDB, 
			0x7F, 0x05, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xD9, 0x74, 
			0x0B, 0x8B}
		};
	#endif
	
	void *ResampleOut = NULL, *Resize = NULL;
	if (!getTextVAAndSize()) {
		goto error;
	}
	for (int i = 0; i < patterns; i++) {
		ResampleOut = memmem(textVA, textSize, pattern[i].ResampleOut, sizeof(pattern[i].ResampleOut));
		if (ResampleOut == NULL) {
			continue;
		}
		Resize = memmem(textVA, textSize, pattern[i].Resize, sizeof(pattern[i].Resize));
		p.ResampleOut = (uint8_t *)ResampleOut;
		p.orig = pattern[i].ResampleOut;
		p.origSize = sizeof(pattern[i].ResampleOut);
		break;
	}
	if (ResampleOut == NULL || Resize == NULL) {
		MessageBox(NULL, "Reaper version not supported", "", 0);
		return 0;
	}
	
	WDL_HeapBuf::pResize = decltype(WDL_HeapBuf::pResize)(Resize);
	if (!patch()) {
		goto error;
	}
	
	CreateThread(NULL, 0, MessageBoxThread, NULL, 0, 0);
	loaded = true;
	return 1;

error:
	MessageBox(NULL, "Error loading resampler", "", 0);
	return 0;
}
}